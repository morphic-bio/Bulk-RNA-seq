<!-- Generated by SpecStory -->

# Extract AWK Script to Separate File (2025-05-26 01:10:29)

_**User**_

extract the awk script out into its own file so that we don't have to quote it. Call it from filterChrY.sh

---

_**Assistant**_

<think>
The task is to extract the complex AWK script from the `filterSequence` function in `filterChrY.sh` into a separate file, and then modify the original script to call this new file instead of embedding the AWK script directly.

Let's look at the AWK script in question. It's this part in the `filterSequence` function:

```awk
awk -v ynamesFile=\"${ynamesArray[0]}\" -v outputFileY=\"$outputFileY\" '
BEGIN {
    # Load the ynames file into an associative array
    while ((getline line < ynamesFile) > 0) {
        ynames[line] = 1;
    }
    close(ynamesFile); # Close the ynames file after reading

    # Determine how to handle output to outputFileY
    is_gzipped_y = (outputFileY ~ /\.gz$/);
    if (is_gzipped_y) {
        # Construct the command string for piping to gzip, ensuring outputFileY is quoted
        # This command will be executed by a shell invoked by awk
        y_destination_string = "gzip -c > \"" outputFileY "\"";
    } else {
        # For non-gzipped output, y_destination_string is just the filename for awk's redirection
        y_destination_string = outputFileY;
    }
}
{
    # Check if the first column is NOT in the ynames array
    # ignore the \"@\"
    firstColumn = substr(\$1, 2);
    if (!(firstColumn in ynames)) {
        # Print this line and the next three lines to standard output (non-Y reads)
        print;
        for (i = 0; i < 3; ++i) {
            if (getline <= 0) break;
            print;
        }
    } else {
        # Print this line and the next three lines to Y reads file
        if (is_gzipped_y) {
            # Pipe to the gzip command string
            print \$0 | y_destination_string;
            for (i = 0; i < 3; ++i) {
                if (getline <= 0) break;
                print \$0 | y_destination_string;
            }
        } else {
            # Redirect directly to the output file
            print \$0 > y_destination_string;
            for (i = 0; i < 3; ++i) {
                if (getline <= 0) break;
                print \$0 > y_destination_string;
            }
        }
    }
}
END {
    # Close the Y chromosome reads output (either the pipe or the file)
    # Must use the exact same string used for opening the pipe/file
    close(y_destination_string);
}'
```

I'll need to:
1. Create a new file with this AWK script
2. Modify the script to accept command-line parameters instead of using AWK variables
3. Update the `filterSequence` function to call this script instead of embedding it

Here's my plan:
1. Create a new file called `filter_fastq.awk` with the AWK script
2. Update the `filterChrY.sh` script to call this new file
</think>

# Extracting AWK Script to Separate File

I'll extract the complex AWK script from `filterChrY.sh` into its own file to improve readability and maintainability. Here's how:

## 1. Create a new AWK script file

```awk:filter_fastq.awk
#!/usr/bin/awk -f
# filter_fastq.awk - Filters FASTQ reads based on whether they are in the ynames file
# 
# Usage: awk -f filter_fastq.awk -v ynamesFile="path/to/ynames.txt" -v outputFileY="path/to/chrY.output"

BEGIN {
    # Load the ynames file into an associative array
    while ((getline line < ynamesFile) > 0) {
        ynames[line] = 1;
    }
    close(ynamesFile); # Close the ynames file after reading

    # Determine how to handle output to outputFileY
    is_gzipped_y = (outputFileY ~ /\.gz$/);
    if (is_gzipped_y) {
        # Construct the command string for piping to gzip, ensuring outputFileY is quoted
        # This command will be executed by a shell invoked by awk
        y_destination_string = "gzip -c > \"" outputFileY "\"";
    } else {
        # For non-gzipped output, y_destination_string is just the filename for awk's redirection
        y_destination_string = outputFileY;
    }
}
{
    # Check if the first column is NOT in the ynames array
    # ignore the "@"
    firstColumn = substr($1, 2);
    if (!(firstColumn in ynames)) {
        # Print this line and the next three lines to standard output (non-Y reads)
        print;
        for (i = 0; i < 3; ++i) {
            if (getline <= 0) break;
            print;
        }
    } else {
        # Print this line and the next three lines to Y reads file
        if (is_gzipped_y) {
            # Pipe to the gzip command string
            print $0 | y_destination_string;
            for (i = 0; i < 3; ++i) {
                if (getline <= 0) break;
                print $0 | y_destination_string;
            }
        } else {
            # Redirect directly to the output file
            print $0 > y_destination_string;
            for (i = 0; i < 3; ++i) {
                if (getline <= 0) break;
                print $0 > y_destination_string;
            }
        }
    }
}
END {
    # Close the Y chromosome reads output (either the pipe or the file)
    # Must use the exact same string used for opening the pipe/file
    close(y_destination_string);
}
```

## 2. Update the filterChrY.sh script

```bash:/mnt/pikachu/filterChrY.sh
#!/bin/bash
function  checkPids() {
    // ... existing code ...
}

function filterSequence() {
    local pattern="$(basename $1 | sed 's/_R[12]_.*//')"
    local ynamesArray=($outputDir/${pattern}*/ynames.txt)

    # Check if ynames.txt exists
    [ -f "${ynamesArray[0]}" ] || return

    
    # Determine if input file is gzipped and set the appropriate command to read it
    local fileCmd
    local outputCmd
    local outputCmdY

    # Get the directory of the first ynames.txt file
    local ynamesDir=$(dirname "${ynamesArray[0]}")


    # Get the basename of the input file and construct the output filename
    local baseName=$(basename "$1")
    local namePart="${baseName%%.*}"
    local extension="${baseName#*.}"
    local outputFile="$ynamesDir/${namePart}.filtered.${extension}"
    # New file for Y chromosome reads
    local outputFileY="$ynamesDir/${namePart}.chrY.${extension}"
    
    # Skip if files exist and overwrite is not set
    [[ -f "$outputFile" && -f "$outputFileY" && -z "$overwrite" ]] && return 
    
    if [[ $1 == *.gz ]]; then
        fileCmd="zcat"
        outputCmd="| gzip > \"$outputFile\""
    else
        fileCmd="cat"
        outputCmd="> \"$outputFile\""
    fi

    # Get the directory of the script
    local script_dir="$(dirname "$(readlink -f "$0")")"
    local awk_script="${script_dir}/filter_fastq.awk"

    # Build and execute the command to create both filtered files
    eval "$fileCmd \"$1\" | awk -v ynamesFile=\"${ynamesArray[0]}\" -v outputFileY=\"$outputFileY\" -f \"$awk_script\" $outputCmd"
}

// ... existing code ...
```

This solution:

1. Creates a new file `filter_fastq.awk` with the AWK script
2. Makes the new file executable and adds a shebang line
3. Updates the `filterSequence` function in `filterChrY.sh` to:
   - Find the directory of the script to locate the AWK script
   - Call the AWK script with `-f` instead of embedding the script inline

The AWK script accepts the same variables (`ynamesFile` and `outputFileY`) but is now in a separate file, making the code more maintainable and easier to read.

Make sure to make the new AWK script executable with:
```
chmod +x filter_fastq.awk
```

---

